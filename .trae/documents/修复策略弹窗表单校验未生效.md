## 问题定位
- `policyRules` 未暴露到模板，`:rules="policyRules"`实际为 `undefined`，导致策略校验不生效（src/views/manage/vm/index.vue:327 未包含 `policyRules`）。
- 两个对话框的 `<el-form>` 使用了同一个 `ref="vmRef"`，`submitForm` 中始终调用 `$refs["vmRef"].validate(...)`，在策略弹窗中没有校验策略表单（src/views/manage/vm/index.vue:246, 458-465）。
- 其他绑定正确：`prop="policyId"` 与 `v-model="form.policyId"` 一致，`trigger:"change"` 适配 `ElSelect`（src/views/manage/vm/index.vue:247-259, 322-324）。

## 修复方案
- 暴露规则到模板：在 `toRefs(data)` 中加入 `policyRules`。
  - 修改为：`const { queryParams, form, rules, policyRules } = toRefs(data);`（src/views/manage/vm/index.vue:327）。
- 分离两个表单的 ref，避免校验指向错误：
  - 策略弹窗表单改为 `ref="policyRef"`（src/views/manage/vm/index.vue:246）。
- 根据当前打开的弹窗选择正确的表单进行校验：
  - 将 `submitForm` 改为：
```
function submitForm() {
  const refName = policyOpen.value ? "policyRef" : "vmRef";
  proxy.$refs[refName].validate((valid) => {
    if (valid) {
      if (form.value.id != null) {
        updateVm(form.value).then(() => {
          proxy.$modal.msgSuccess("修改成功");
          open.value = false;
          policyOpen.value = false;
          getList();
        });
      } else {
        addVm(form.value).then(() => {
          proxy.$modal.msgSuccess("新增成功");
          open.value = false;
          getList();
        });
      }
    }
  });
}
```
- 可选：保留 `proxy.resetForm("vmRef")`；如需在策略弹窗取消时清理校验状态，可在 `cancel()` 中根据 `policyOpen` 调用 `proxy.resetForm("policyRef")`。

## 验证方案
- 打开策略弹窗，`form.policyId = null` 时点击“确定”，应出现“策略不能为空”的校验提示（src/views/manage/vm/index.vue:322-324）。
- 选择任一策略后再点击“确定”，应通过校验并调用 `updateVm`，弹窗关闭，列表刷新（src/views/manage/vm/index.vue:462-467）。
- 设备编辑弹窗中的 `nodeId`、`vmTypeId` 原有校验保持不变（src/views/manage/vm/index.vue:316-321）。

## 变更影响面
- 仅影响策略弹窗的表单校验与提交流程；设备新增/修改流程不受影响。

请确认以上方案，确认后我将进行代码修改并本地验证。